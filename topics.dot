digraph topics {
  graph [bgcolor=black, color=white, fontcolor=white]
  node [bgcolor=black, color=white, fontcolor=white]
  edge [bgcolor=black, color=white, fontcolor=white]

  newrank=true
  rankdir=LR
  node [shape=box]

  subgraph cluster_topical {
    label="Staying on Topic"
    lc [label="What is lambda calculus?\nConstructing a minimal programming language."]
    monoids [label="What are monoids?\nUnderstanding and using `Data.Monoid`."]
    functors
    [label="What are functors?\nUnderstanding and using `Data.Functor` and friends."]
    applicatives
    [label="What are applicative functors?\nUnderstanding and using `Control.Applicative` and friends."]
    monads
    [label="What are monads?\nUnderstanding and using `Control.Monad` and friends."]
    traversals
    [label="What are traversals?\nUnderstanding and using `Data.Foldable` and `Data.Traversable`."]
    arrows [label="What are arrows?\nUnderstanding and using `Control.Arrow`."]
  }

  subgraph cluster_theory {
    label="Type Theory"
    stlc [label="How about typed lambda calculus?\nFitting simple types into a simple theory."]
    cardinal [label="Why calculate type inhabitants?\nPutting cardinal space into good use."]
    dependent [label="Is there more to types?\nThinking about linear and dependent types."]
    proofs [label="How to prove and check theorems?\nTaking a gander at Coq and Idris."]
    foundations [label="What does it mean to exist?\nPondering about axiomatic systems and mathematical foundations."]
  }

  subgraph cluster_design {
    label="Program Design"
    plan [label="Where to start?\nMusings about types in planning and refactoring."]
    flow [label="How to express things better?\nFocusing on data flow instead of control flow."]
    parsec [label="How to parse things?\nLooking at `Text.Parsec` or its descendants."]
    repa [label="How to crunch numbers?\nLooking at `Data.Array.Repa` and `Data.Array.Accelerate`."]
    concurrent [label="How to manage threads?\nWorking with concurrent control flow abstractions."]
    work [label="What is the fabled great good?\nLooking at practical applications and future work."]
  }

  subgraph cluster_automation {
    label="Tools for Automation"
    ghc [label="How to improve the user experience?\nConfiguring and using ghc and ghci."]
    cabal [label="How to manage projects?\nUsing modules and Cabal."]
    pointfree [label="How to work with composition chains?\nMaking use of pointfree and pointful."]
    djinn [label="How to avoid writing code?\nTrying out djinn and typed holes."]
  }

  subgraph cluster_tricks {
    label="Type System Tricks"
    mt [label="What are monad transformers?\nLooking at a seemingly scary subject."]
    comp [label="How to compose functions?\nBuilding ridiculous chains without a variable in sight."]
    printf [label="How to define functions with variable arity?\nLooking at printf from `Text.Printf`."]
    schemes [label="What are recursion schemes?\nAbstracting away the little control flow that is left."]
    extensions [label="Is there more to the type system?\nUsing language extensions to enhance the type system."]
  }

  subgraph cluster_performance {
    label="Performance and Profiling"
    mutable [label="How to transform mutable data?\nUsing `Control.Monad.ST` and `Data.IORef`."]
    habits [label="How to write fast code?\nDeveloping good habits."]
    seq [label="How to control laziness?\nUsing `seq` and `BangPatterns`."]
    parallel [label="How to employ multiple cores?\nWorking with parallel algorithms."]
    prof [label="How to find and eliminate performance problems?\nProducing wrong results faster."]
  }

  subgraph cluster_implementation {
    label="Implementation Details"
    classes [label="What are type classes?\nImplementing type classes without type classes."]
    io [label="How does IO actually work?\nUncovering the magic of side effects."]
    prim [label="What happens under the hood?\nBringing out `MagicHash`, `GHC.Exts` and `GHC.Prim`."]
  }

  functors -> applicatives
  monads -> arrows
  monads -> mt
  monads -> io
  lc -> stlc
  seq -> prof
  concurrent -> parallel
  applicatives -> parsec
  flow -> repa
  parallel -> repa
  dependent -> proofs
  comp -> pointfree
  proofs -> foundations
  foundations -> proofs
  traversals -> flow
}
