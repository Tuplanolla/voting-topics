digraph topics {
  graph [bgcolor=black, color=white, fontcolor=white]
  node [bgcolor=black, color=white, fontcolor=white]
  edge [bgcolor=black, color=white, fontcolor=white]

  newrank=true
  rankdir=LR
  node [shape=box]

  subgraph cluster_automation {
    label="Tools for Automation"
    ghc [label="How to improve the user experience?\nConfiguring and using `ghc` and `ghci`."]
    cabal [label="How to manage projects?\nUsing modules and `cabal`."]
    pointfree [label="How to work with function composition?\nMaking use of `pointfree` and `pointful`."]
    djinn [label="How to avoid writing code?\nTrying out `djinn`."]
  }

  subgraph cluster_cases {
    label="Case Studies"
    parsec [label="How to parse things?\nLooking at `Text.Parsec` or its descendants."]
    repa [label="How to crunch numbers?\nLooking at `Data.Array.Repa` and `Data.Array.Accelerate`."]
    servant [label="How to build web services?\nLooking at `Servant.API` or something."]
  }

  subgraph cluster_design {
    label="Program Design"
    plan [label="How to get things done?\nUsing types for planning and refactoring."]
    concurrent [label="How to manage threads?\nWorking with concurrent control flow abstractions."]
    flow [label="How to express things better?\nFocusing on data flow instead of control flow."]
    work [label="What is the fabled great good?\nLooking at practical applications and future work."]
  }

  subgraph cluster_implementation {
    label="Implementation Details"
    classes [label="What are type classes?\nImplementing type classes without type classes."]
    io [label="How does IO actually work?\nUncovering the magic of side effects."]
    prim [label="What happens under the hood?\nBringing out `MagicHash`, `GHC.Exts` and `GHC.Prim`."]
    core [label="How does GHC work?\nLooking at the compilation process."]
    foreign [label="How to interact with other languages?\nUsing `Foreign` and `Data.Binary`."]
  }

  subgraph cluster_performance {
    label="Performance and Profiling"
    mutable [label="How to transform mutable data?\nUsing `Control.Monad.ST` and `Data.IORef`."]
    habits [label="How to write fast code?\nDeveloping good habits."]
    seq [label="How to control laziness?\nUsing `seq` and `BangPatterns`."]
    parallel [label="How to employ multiple cores?\nWorking with parallel algorithms."]
    prof [label="How to find and eliminate performance problems?\nProducing wrong results faster."]
  }

  subgraph cluster_topical {
    label="Staying on Topic"
    lc
    [label="What is lambda calculus?\nConstructing a minimal programming language."]
    stlc [label="How about typed lambda calculus?\nFitting simple types into a simple theory."]
    hm [label="Can we make the typed lambda calculus stronger?\nBuilding the Hindley--Milner type system."]
    functors
    [label="What are functors?\nUnderstanding and using `Data.Functor` and friends."]
    applicatives
    [label="What are applicative functors?\nUnderstanding and using `Control.Applicative` and friends."]
    monads
    [label="What are monads?\nUnderstanding and using `Control.Monad` and friends."]
    mt
    [label="What are monad transformers?\nLooking at `Control.Monad.Trans`."]
    free
    [label="What are free monads?\nUnderstanding and using `Control.Monad.Free`."]
    traversals [label="What are traversals?\nUnderstanding and using `Data.Foldable` and `Data.Traversable`."]
    monoids [label="What are monoids?\nUnderstanding and using `Data.Monoid`."]
    arrows [label="What are arrows?\nUnderstanding and using `Control.Arrow`."]
  }

  subgraph cluster_tricks {
    label="Type System Tricks"
    composition [label="How to reason about function composition?\nMaking sense of expressions without a variable in sight."]
    extensions [label="Is there more to the type system?\nUsing language extensions to enhance the type system."]
    printf [label="How to define functions with variable arity?\nLooking at `Text.Printf`."]
    unsafe [label="What is considered unsafe?\nUsing `System.IO.Unsafe` correctly."]
    schemes [label="What are recursion schemes?\nAbstracting away control flow itself."]
  }

  /*
  subgraph cluster_theory {
    label="Type Theory (Not on This Course)"
    cardinal [label="Why calculate type inhabitants?\nPutting cardinal space into good use."]
    dependent [label="Is there more to types?\nThinking about linear and dependent types."]
    proofs [label="How to prove and check theorems?\nWorking with Coq."]
    foundations [label="How deep does it go?\nGetting lost in axiomatic systems of mathematical foundations."]
  }
  */

  subgraph cluster_skills {
    label="Small Survey of Skills"
    hsm [label="I am comfortable with highschool mathematics."]
    fp [label="I have used more than one functional programming language."]
    c [label="I can read C programs."]
    assembly [label="I can read assembly programs."]
    algebra [label="I know abstract algebra."]
    logic [label="I know formal logic."]
  }

  lc -> stlc
  stlc -> hm
  applicatives -> parsec
  monads -> arrows
  monads -> io
  monads -> servant
  traversals -> flow
  extensions -> ghc
  concurrent -> parallel
  concurrent -> repa
  flow -> repa
  habits -> prof
  seq -> prof
  composition -> pointfree
  prim -> prof
  prim -> core
}
